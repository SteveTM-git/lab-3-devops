docker build -t flask-demo .
docker run -p 5001:5000 flask-demo


 lab 5:
 docker run -d \
  --name jenkins \
  -p 8080:8080 \
  -p 50000:50000 \
  -v jenkins_home:/var/jenkins_home \
  jenkins/jenkins:lts

ğŸ‘‰ http://localhost:8080

âœ… STEP 1 â€” Set up Jenkins using Docker Compose
1. Create project folder
mkdir ~/jenkins-static-site
cd ~/jenkins-static-site
2. Create docker-compose.yml
version: '3.8'

services:
  jenkins:
    image: jenkins/jenkins:lts
    container_name: jenkins
    restart: unless-stopped
    ports:
      - "8080:8080"
      - "50000:50000"
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock

volumes:
  jenkins_home:
    driver: local
3. Start Jenkins
docker compose up -d
4. Get initial admin password
docker exec jenkins cat /var/jenkins_home/secrets/initialAdminPassword
5. Open Jenkins
ğŸ‘‰ http://localhost:8080
Install Suggested Plugins
Create Admin User
Jenkins is ready!

docker logs jenkins

1. Create a new job
Click New Item
Enter name: karunya-site-pipeline
Choose Pipeline
Scroll down â†’ In the Pipeline section â†’ Select Pipeline script
Paste this corrected pipeline script:

pipeline script

pipeline {
    agent any

    stages {
        stage('Generate site') {
            steps {
                script {
                    sh 'rm -rf site || true'
                    sh 'mkdir -p site/assets'

                    writeFile file: 'site/index.html', text: """
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Karunya University â€” Simple Site</title>
<link rel="stylesheet" href="assets/style.css"/>
</head>
<body>
<header class="site-header">
<div class="container">
<h1>Karunya University</h1>
<p class="tagline">Values â€” Knowledge â€” Service</p>
</div>
</header>
<main class="container">
<section class="card">
<h2>About Karunya University</h2>
<p>Karunya Institute of Technology and Sciences is a leading
centre for higher education in India.</p>
</section>
</main>
<footer class="site-footer container">
<p>&copy; ${new Date().format('yyyy')} Karunya University â€”
Generated by Jenkins</p>
</footer>
</body>
</html>
"""

                    writeFile file: 'site/assets/style.css', text: """
body { font-family: Arial, sans-serif; margin:0; }
.container { max-width:800px; margin:0 auto; padding:20px; }
.site-header { background:#0b3d91; color:#fff; padding:20px; }
.tagline { font-size:14px; opacity:0.8; }
.card { background:#fff; border:1px solid #ddd; padding:15px; margin:15px 0; border-radius:6px; }
.site-footer { text-align:center; font-size:12px; color:#555; margin-top:20px; }
"""
                }
            }
        }

        stage('Publish site') {
            steps {
                publishHTML([
                    reportDir: 'site',
                    reportFiles: 'index.html',
                    reportName: 'Karunya University - Simple Site',
                    keepAll: true,
                    alwaysLinkToLastBuild: true,
                    allowMissing: false
                ])
            }
        }
    }

    post {
        always {
            archiveArtifacts artifacts: 'site/**', fingerprint: true
        }
    }
}



lab 6:

âœ… Prerequisites
You must have:
Docker / Docker Desktop
kubectl
Minikube
Terminal (macOS/Linux) or PowerShell (Windows)
Verify installations:
docker --version
kubectl version --client
minikube version
ğŸŸ© STEP 0 â€” Start Kubernetes Cluster
Start Minikube:
minikube start --driver=docker
Check status:
minikube status
kubectl get nodes
Node must be Ready.
ğŸŸ¦ STEP 1 â€” Create Your First Pod
1ï¸âƒ£ Create a YAML file: nginx-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    app: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
      ports:
        - containerPort: 80
2ï¸âƒ£ Apply the YAML
kubectl apply -f nginx-pod.yaml
3ï¸âƒ£ Check Pod Status
kubectl get pods
Expected:
nginx-pod   1/1   Running
4ï¸âƒ£ Describe Pod
kubectl describe pod nginx-pod
5ï¸âƒ£ Access the Pod (Port Forward)
kubectl port-forward pod/nginx-pod 8080:80
Open:
ğŸ‘‰ http://localhost:8080
6ï¸âƒ£ Delete Pod
kubectl delete pod nginx-pod
ğŸŸ¨ STEP 2 â€” Create Deployment & Scale It
1ï¸âƒ£ Create deployment using kubectl:
kubectl create deployment my-nginx --image=nginx
Check deployments:
kubectl get deployments
Check pods:
kubectl get pods -l app=my-nginx
2ï¸âƒ£ Scale deployment
kubectl scale deployment my-nginx --replicas=3
Verify:
kubectl get pods
You should see 3 pods.
3ï¸âƒ£ Rolling update
kubectl set image deployment/my-nginx nginx=nginx:1.25
kubectl rollout status deployment/my-nginx
4ï¸âƒ£ Rollback if needed
kubectl rollout undo deployment/my-nginx
ğŸŸ¥ STEP 3 â€” Expose Deployment as a Service
Create NodePort service:
kubectl expose deployment my-nginx --type=NodePort --port=80
See services:
kubectl get svc
Get auto-generated URL:
minikube service my-nginx --url
Open the printed URL in the browser.
Delete service:
kubectl delete svc my-nginx
ğŸ§¹ STEP 4 â€” Clean Up
Delete deployment:
kubectl delete deployment my-nginx
Delete all services:
kubectl delete svc --all
Delete all resources (safe):
kubectl delete all --all -n default
Stop Minikube:
minikube stop
Delete Minikube:
minikube delete

lab 7:
ğŸš€ LAB: Kubernetes Deployment & Service for Python App from Docker Hub
âœ… Prerequisites
Make sure:
minikube start --driver=docker
kubectl get nodes
Node status must be:
Ready
ğŸŸ¦ STEP 1 â€” Pull a Python Docker Image
You can use a sample image from Docker Hub:
docker pull dockersamples/flaskapp
This confirms your Docker Hub access works.
ğŸŸ© STEP 2 â€” Create Kubernetes Deployment
Create a file:
python-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: python-web-deployment
  labels:
    app: python-web
spec:
  replicas: 2
  selector:
    matchLabels:
      app: python-web
  template:
    metadata:
      labels:
        app: python-web
    spec:
      containers:
        - name: python-web
          image: dockersamples/flaskapp:latest
          ports:
            - containerPort: 5000
Apply deployment:
kubectl apply -f python-deployment.yaml
Check status:
kubectl get deployments
kubectl get pods
kubectl describe deployment python-web-deployment
You should see 2 pods running.
ğŸŸ¨ STEP 3 â€” Expose Deployment as a NodePort Service
Create a file:
python-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: python-web-service
spec:
  type: NodePort
  selector:
    app: python-web
  ports:
    - protocol: TCP
      port: 5000
      targetPort: 5000
Apply service:
kubectl apply -f python-service.yaml
Check services:
kubectl get svc
You will see something like:
python-web-service   NodePort   10.111.34.27   <none>   5000:3xxxx/TCP
(3xxxx is the auto-chosen NodePort)
ğŸŒ STEP 4 â€” Access the Python Web App
Use Minikube:
minikube service python-web-service --url
Output example:
http://127.0.0.1:32654
Open this URL in your browser â€” your Python Flask app will load.
ğŸ§¹ STEP 5 â€” Cleanup After Lab
kubectl delete deployment python-web-deployment
kubectl delete svc python-web-service
Stop Minikube:
minikube stop
Delete cluster:
minikube delete


lab 4:
ğŸš€ CI Pipeline Lab: Python App â†’ GitHub Actions â†’ Docker Hub
âœ… GOAL
You will build a complete CI workflow that:
Runs Python tests
Builds a Docker image
Pushes the image to Docker Hub
(Optional) Creates version tags like v1.0.0
ğŸ§° PREREQUISITES
GitHub account
Docker Hub account
Git installed
Python 3.11+
Docker Desktop (optional)
ğŸŸ¦ STEP 1 â€” Create project folder
mkdir python-ci-docker-lab
cd python-ci-docker-lab
ğŸŸ© STEP 2 â€” Create Application Files
app.py
def add(a, b):
    return a + b

if __name__ == "__main__":
    print("Hello from Python CI Lab!")
    print("2 + 3 =", add(2, 3))
tests/test_app.py
from app import add

def test_add():
    assert add(2, 3) == 5
    assert add(-1, 1) == 0
requirements.txt
pytest==8.3.2
Dockerfile
FROM python:3.11-slim
WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .
CMD ["python", "app.py"]
.gitignore
__pycache__/
.venv/
.pytest_cache/
.DS_Store
*.pyc
ğŸŸ§ STEP 3 â€” Add GitHub Actions Workflow
Create folder:
mkdir -p .github/workflows
Create:
.github/workflows/ci-dockerhub.yml
name: ci-dockerhub

on:
  push:
    branches: [ "main" ]
    tags: [ "*" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-test-push:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install deps
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Run tests
      run: pytest -q

    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ secrets.DOCKERHUB_USERNAME }}/python-ci-lab
        tags: |
          type=raw,value=latest,enable={{is_default_branch}}
          type=sha,prefix=sha-,format=short
          type=ref,event=tag

    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Build and push image
      uses: docker/build-push-action@v6
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
ğŸŸ¨ STEP 4 â€” (Optional) Local testing
python app.py
pytest -q
docker build -t yourname/python-ci-lab:local .
docker run --rm yourname/python-ci-lab:local
ğŸŸ¥ STEP 5 â€” Initialize Git & Push to GitHub
git init
git add .
git commit -m "init lab"
git branch -M main
git remote add origin https://github.com/<your-username>/python-ci-docker-lab.git
git push -u origin main
ğŸŸª STEP 6 â€” Add GitHub Secrets
In GitHub â†’ Repo â†’ Settings â†’ Secrets â†’ Actions:
Create:
DOCKERHUB_USERNAME
DOCKERHUB_TOKEN
ğŸŸ© STEP 7 â€” Watch CI Pipeline
Go to:
ğŸ‘‰ GitHub â†’ Actions â†’ ci-dockerhub
You will see steps:
Checkout
Install deps
Run tests
Build Docker
Push to Docker Hub
ğŸŸ¦ STEP 8 â€” Verify Image on Docker Hub
Go to:
ğŸ‘‰ https://hub.docker.com/repository/docker/<username>/python-ci-lab
Image should appear automatically.
ğŸŸ« STEP 9 â€” Release with a tag (optional)
git tag v1.0.0
git push origin v1.0.0
GitHub Actions will build a versioned Docker tag like:
<user>/python-ci-lab:v1.0.0
